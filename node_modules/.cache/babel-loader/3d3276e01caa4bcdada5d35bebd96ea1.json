{"ast":null,"code":"import { toRefs, computed } from \"vue\";\nimport { getIndexByStartLoc } from \"../utils/algorithm.js\";\nimport { getRangeIndex, getItemRelativeTop, getCompareItemRelativeTop, getScrollPercentage } from \"../utils/index.js\";\n\nfunction useScrollTo(props) {\n  const {\n    isVirtual,\n    isStaticItemHeight,\n    data,\n    rangeState,\n    viewportRef,\n    scrollTop,\n    visibleCount,\n    getItemHeightOrDefault,\n    getItemHeightOrDefaultByIndex\n  } = toRefs(props);\n  const itemCount = computed(() => data.value.length);\n\n  const getItemKeyByIndex = index => {\n    var _a;\n\n    return (_a = data.value[index]) == null ? void 0 : _a.key;\n  };\n\n  const fixScrollTo = relativeScroll => {\n    if (!viewportRef.value) return null;\n    const {\n      itemIndex: compareItemIndex,\n      relativeTop: compareItemRelativeTop\n    } = relativeScroll;\n    const {\n      scrollHeight,\n      clientHeight\n    } = viewportRef.value;\n    const originScrollTop = scrollTop.value;\n    const maxScrollTop = scrollHeight - clientHeight;\n    let bestSimilarity = Number.MAX_VALUE;\n    let bestScrollTop = -1;\n    let bestItemIndex = -1;\n    let bestItemOffsetPtg = -1;\n    let bestStartIndex = -1;\n    let bestEndIndex = -1;\n    let missSimilarity = 0;\n\n    for (let i = 0; i < maxScrollTop; i++) {\n      const scrollTop2 = getIndexByStartLoc(0, maxScrollTop, originScrollTop, i);\n      const scrollPtg = getScrollPercentage({\n        scrollTop: scrollTop2,\n        scrollHeight,\n        clientHeight\n      });\n      const {\n        itemIndex,\n        itemOffsetPtg,\n        startIndex,\n        endIndex\n      } = getRangeIndex(scrollPtg, itemCount.value, visibleCount.value);\n\n      if (startIndex <= compareItemIndex && compareItemIndex <= endIndex) {\n        const locatedItemRelativeTop = getItemRelativeTop({\n          itemHeight: getItemHeightOrDefaultByIndex.value(itemIndex),\n          itemOffsetPtg,\n          clientHeight,\n          scrollPtg\n        });\n        const compareItemTop = getCompareItemRelativeTop({\n          locatedItemRelativeTop,\n          locatedItemIndex: itemIndex,\n          compareItemIndex,\n          startIndex,\n          endIndex,\n          getItemKeyByIndex,\n          getItemHeightOrDefault: getItemHeightOrDefault.value\n        });\n        const similarity = Math.abs(compareItemTop - compareItemRelativeTop);\n\n        if (similarity < bestSimilarity) {\n          bestSimilarity = similarity;\n          bestScrollTop = scrollTop2;\n          bestItemIndex = itemIndex;\n          bestItemOffsetPtg = itemOffsetPtg;\n          bestStartIndex = startIndex;\n          bestEndIndex = endIndex;\n          missSimilarity = 0;\n        } else {\n          missSimilarity += 1;\n        }\n      }\n\n      if (missSimilarity > 10) {\n        break;\n      }\n    }\n\n    return bestScrollTop === -1 ? null : {\n      scrollTop: bestScrollTop,\n      itemIndex: bestItemIndex,\n      itemOffsetPtg: bestItemOffsetPtg,\n      startIndex: bestStartIndex,\n      endIndex: bestEndIndex\n    };\n  };\n\n  const prepareScrollTo = options => {\n    if (!viewportRef.value) return null;\n\n    if (typeof options === \"number\") {\n      viewportRef.value.scrollTop = options;\n      return null;\n    }\n\n    const index = \"index\" in options ? options.index : \"key\" in options ? data.value.findIndex(item2 => item2.key === options.key) : 0;\n    const item = data.value[index];\n\n    if (!item) {\n      return null;\n    }\n\n    let align = options.align || \"auto\";\n    const {\n      clientHeight,\n      scrollTop: scrollTop2\n    } = viewportRef.value;\n\n    if (isVirtual.value && !isStaticItemHeight.value) {\n      if (align === \"auto\") {\n        const {\n          itemIndex,\n          itemOffsetPtg\n        } = rangeState.value;\n\n        if (Math.abs(itemIndex - index) < visibleCount.value) {\n          let itemTop2 = getItemRelativeTop({\n            itemHeight: getItemHeightOrDefaultByIndex.value(index),\n            itemOffsetPtg,\n            clientHeight,\n            scrollPtg: getScrollPercentage(viewportRef.value)\n          });\n\n          if (index < itemIndex) {\n            for (let i = index; i < itemIndex; i++) {\n              itemTop2 -= getItemHeightOrDefaultByIndex.value(i);\n            }\n          } else {\n            for (let i = itemIndex; i < index; i++) {\n              itemTop2 += getItemHeightOrDefaultByIndex.value(i);\n            }\n          }\n\n          if (itemTop2 < 0 || itemTop2 > clientHeight) {\n            align = itemTop2 < 0 ? \"top\" : \"bottom\";\n          } else {\n            return null;\n          }\n        } else {\n          align = index < itemIndex ? \"top\" : \"bottom\";\n        }\n      }\n\n      return {\n        itemIndex: index,\n        relativeTop: align === \"top\" ? 0 : clientHeight - getItemHeightOrDefaultByIndex.value(index),\n        startIndex: Math.max(0, index - visibleCount.value),\n        endIndex: Math.min(itemCount.value - 1, index + visibleCount.value)\n      };\n    }\n\n    const indexItemHeight = getItemHeightOrDefaultByIndex.value(index);\n    let itemTop = 0;\n\n    for (let i = 0; i < index; i++) {\n      itemTop += getItemHeightOrDefaultByIndex.value(i);\n    }\n\n    const itemBottom = itemTop + indexItemHeight;\n\n    if (align === \"auto\") {\n      if (itemTop < scrollTop2) {\n        align = \"top\";\n      } else if (itemBottom > scrollTop2 + clientHeight) {\n        align = \"bottom\";\n      }\n    }\n\n    if (align === \"top\") {\n      viewportRef.value.scrollTop = itemTop;\n    } else if (align === \"bottom\") {\n      viewportRef.value.scrollTop = itemTop - (clientHeight - indexItemHeight);\n    }\n\n    return null;\n  };\n\n  return {\n    fixScrollTo,\n    prepareScrollTo\n  };\n}\n\nexport { useScrollTo };","map":{"version":3,"names":["toRefs","computed","getIndexByStartLoc","getRangeIndex","getItemRelativeTop","getCompareItemRelativeTop","getScrollPercentage","useScrollTo","props","isVirtual","isStaticItemHeight","data","rangeState","viewportRef","scrollTop","visibleCount","getItemHeightOrDefault","getItemHeightOrDefaultByIndex","itemCount","value","length","getItemKeyByIndex","index","_a","key","fixScrollTo","relativeScroll","itemIndex","compareItemIndex","relativeTop","compareItemRelativeTop","scrollHeight","clientHeight","originScrollTop","maxScrollTop","bestSimilarity","Number","MAX_VALUE","bestScrollTop","bestItemIndex","bestItemOffsetPtg","bestStartIndex","bestEndIndex","missSimilarity","i","scrollTop2","scrollPtg","itemOffsetPtg","startIndex","endIndex","locatedItemRelativeTop","itemHeight","compareItemTop","locatedItemIndex","similarity","Math","abs","prepareScrollTo","options","findIndex","item2","item","align","itemTop2","max","min","indexItemHeight","itemTop","itemBottom"],"sources":["/www/wwwroot/admin/node_modules/@arco-design/web-vue/es/_components/virtual-list/hooks/use-scroll-to.js"],"sourcesContent":["import { toRefs, computed } from \"vue\";\nimport { getIndexByStartLoc } from \"../utils/algorithm.js\";\nimport { getRangeIndex, getItemRelativeTop, getCompareItemRelativeTop, getScrollPercentage } from \"../utils/index.js\";\nfunction useScrollTo(props) {\n  const {\n    isVirtual,\n    isStaticItemHeight,\n    data,\n    rangeState,\n    viewportRef,\n    scrollTop,\n    visibleCount,\n    getItemHeightOrDefault,\n    getItemHeightOrDefaultByIndex\n  } = toRefs(props);\n  const itemCount = computed(() => data.value.length);\n  const getItemKeyByIndex = (index) => {\n    var _a;\n    return (_a = data.value[index]) == null ? void 0 : _a.key;\n  };\n  const fixScrollTo = (relativeScroll) => {\n    if (!viewportRef.value)\n      return null;\n    const { itemIndex: compareItemIndex, relativeTop: compareItemRelativeTop } = relativeScroll;\n    const { scrollHeight, clientHeight } = viewportRef.value;\n    const originScrollTop = scrollTop.value;\n    const maxScrollTop = scrollHeight - clientHeight;\n    let bestSimilarity = Number.MAX_VALUE;\n    let bestScrollTop = -1;\n    let bestItemIndex = -1;\n    let bestItemOffsetPtg = -1;\n    let bestStartIndex = -1;\n    let bestEndIndex = -1;\n    let missSimilarity = 0;\n    for (let i = 0; i < maxScrollTop; i++) {\n      const scrollTop2 = getIndexByStartLoc(0, maxScrollTop, originScrollTop, i);\n      const scrollPtg = getScrollPercentage({\n        scrollTop: scrollTop2,\n        scrollHeight,\n        clientHeight\n      });\n      const { itemIndex, itemOffsetPtg, startIndex, endIndex } = getRangeIndex(scrollPtg, itemCount.value, visibleCount.value);\n      if (startIndex <= compareItemIndex && compareItemIndex <= endIndex) {\n        const locatedItemRelativeTop = getItemRelativeTop({\n          itemHeight: getItemHeightOrDefaultByIndex.value(itemIndex),\n          itemOffsetPtg,\n          clientHeight,\n          scrollPtg\n        });\n        const compareItemTop = getCompareItemRelativeTop({\n          locatedItemRelativeTop,\n          locatedItemIndex: itemIndex,\n          compareItemIndex,\n          startIndex,\n          endIndex,\n          getItemKeyByIndex,\n          getItemHeightOrDefault: getItemHeightOrDefault.value\n        });\n        const similarity = Math.abs(compareItemTop - compareItemRelativeTop);\n        if (similarity < bestSimilarity) {\n          bestSimilarity = similarity;\n          bestScrollTop = scrollTop2;\n          bestItemIndex = itemIndex;\n          bestItemOffsetPtg = itemOffsetPtg;\n          bestStartIndex = startIndex;\n          bestEndIndex = endIndex;\n          missSimilarity = 0;\n        } else {\n          missSimilarity += 1;\n        }\n      }\n      if (missSimilarity > 10) {\n        break;\n      }\n    }\n    return bestScrollTop === -1 ? null : {\n      scrollTop: bestScrollTop,\n      itemIndex: bestItemIndex,\n      itemOffsetPtg: bestItemOffsetPtg,\n      startIndex: bestStartIndex,\n      endIndex: bestEndIndex\n    };\n  };\n  const prepareScrollTo = (options) => {\n    if (!viewportRef.value)\n      return null;\n    if (typeof options === \"number\") {\n      viewportRef.value.scrollTop = options;\n      return null;\n    }\n    const index = \"index\" in options ? options.index : \"key\" in options ? data.value.findIndex((item2) => item2.key === options.key) : 0;\n    const item = data.value[index];\n    if (!item) {\n      return null;\n    }\n    let align = options.align || \"auto\";\n    const { clientHeight, scrollTop: scrollTop2 } = viewportRef.value;\n    if (isVirtual.value && !isStaticItemHeight.value) {\n      if (align === \"auto\") {\n        const { itemIndex, itemOffsetPtg } = rangeState.value;\n        if (Math.abs(itemIndex - index) < visibleCount.value) {\n          let itemTop2 = getItemRelativeTop({\n            itemHeight: getItemHeightOrDefaultByIndex.value(index),\n            itemOffsetPtg,\n            clientHeight,\n            scrollPtg: getScrollPercentage(viewportRef.value)\n          });\n          if (index < itemIndex) {\n            for (let i = index; i < itemIndex; i++) {\n              itemTop2 -= getItemHeightOrDefaultByIndex.value(i);\n            }\n          } else {\n            for (let i = itemIndex; i < index; i++) {\n              itemTop2 += getItemHeightOrDefaultByIndex.value(i);\n            }\n          }\n          if (itemTop2 < 0 || itemTop2 > clientHeight) {\n            align = itemTop2 < 0 ? \"top\" : \"bottom\";\n          } else {\n            return null;\n          }\n        } else {\n          align = index < itemIndex ? \"top\" : \"bottom\";\n        }\n      }\n      return {\n        itemIndex: index,\n        relativeTop: align === \"top\" ? 0 : clientHeight - getItemHeightOrDefaultByIndex.value(index),\n        startIndex: Math.max(0, index - visibleCount.value),\n        endIndex: Math.min(itemCount.value - 1, index + visibleCount.value)\n      };\n    }\n    const indexItemHeight = getItemHeightOrDefaultByIndex.value(index);\n    let itemTop = 0;\n    for (let i = 0; i < index; i++) {\n      itemTop += getItemHeightOrDefaultByIndex.value(i);\n    }\n    const itemBottom = itemTop + indexItemHeight;\n    if (align === \"auto\") {\n      if (itemTop < scrollTop2) {\n        align = \"top\";\n      } else if (itemBottom > scrollTop2 + clientHeight) {\n        align = \"bottom\";\n      }\n    }\n    if (align === \"top\") {\n      viewportRef.value.scrollTop = itemTop;\n    } else if (align === \"bottom\") {\n      viewportRef.value.scrollTop = itemTop - (clientHeight - indexItemHeight);\n    }\n    return null;\n  };\n  return {\n    fixScrollTo,\n    prepareScrollTo\n  };\n}\nexport { useScrollTo };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}