{"ast":null,"code":"import \"core-js/modules/es.array.includes.js\";\nimport { defineComponent, toRefs, computed, reactive, ref, provide, resolveComponent, openBlock, createElementBlock, normalizeClass, createBlock, mergeProps, withCtx, createVNode, Fragment, renderList } from \"vue\";\nimport { getPrefixCls } from \"../_utils/global-config.js\";\nimport { TreeInjectionKey } from \"./context.js\";\nimport usePickSlots from \"../_hooks/use-pick-slots.js\";\nimport { isLeafNode, isNodeSelectable, isNodeExpandable } from \"./utils/index.js\";\nimport { isNodeCheckable, getCheckedStateByCheck } from \"./utils/check-utils.js\";\nimport TreeNode from \"./node.js\";\nimport { isUndefined, isFunction, isArray } from \"../_utils/is.js\";\nimport useMergeState from \"../_hooks/use-merge-state.js\";\nimport useCheckedState from \"./hooks/use-checked-state.js\";\nimport useTreeData from \"./hooks/use-tree-data.js\";\nimport VirtualList from \"../_components/virtual-list/virtual-list.js\";\nimport _export_sfc from \"../_virtual/plugin-vue_export-helper.js\";\n\nconst _sfc_main = defineComponent({\n  name: \"Tree\",\n  components: {\n    VirtualList,\n    TreeNode\n  },\n  props: {\n    size: {\n      type: String,\n      default: \"medium\"\n    },\n    blockNode: {\n      type: Boolean\n    },\n    defaultExpandAll: {\n      type: Boolean,\n      default: true\n    },\n    multiple: {\n      type: Boolean\n    },\n    checkable: {\n      type: [Boolean, String, Function],\n      default: false\n    },\n    selectable: {\n      type: [Boolean, Function],\n      default: true\n    },\n    checkStrictly: {\n      type: Boolean\n    },\n    checkedStrategy: {\n      type: String,\n      default: \"all\"\n    },\n    defaultSelectedKeys: {\n      type: Array\n    },\n    selectedKeys: {\n      type: Array\n    },\n    defaultCheckedKeys: {\n      type: Array\n    },\n    checkedKeys: {\n      type: Array\n    },\n    defaultExpandedKeys: {\n      type: Array\n    },\n    expandedKeys: {\n      type: Array\n    },\n    data: {\n      type: Array,\n      default: () => []\n    },\n    fieldNames: {\n      type: Object\n    },\n    showLine: {\n      type: Boolean\n    },\n    loadMore: {\n      type: Function\n    },\n    draggable: {\n      type: Boolean\n    },\n    allowDrop: {\n      type: Function\n    },\n    filterTreeNode: {\n      type: Function\n    },\n    virtualListProps: {\n      type: Object\n    },\n    defaultExpandSelected: {\n      type: Boolean\n    },\n    defaultExpandChecked: {\n      type: Boolean\n    },\n    autoExpandParent: {\n      type: Boolean,\n      default: true\n    },\n    halfCheckedKeys: {\n      type: Array\n    },\n    onlyCheckLeaf: {\n      type: Boolean,\n      default: false\n    },\n    animation: {\n      type: Boolean,\n      default: true\n    },\n    actionOnNodeClick: {\n      type: String\n    },\n    disableSelectActionOnly: {\n      type: Boolean,\n      default: false\n    }\n  },\n  emits: {\n    \"select\": (selectedKeys, data) => true,\n    \"update:selectedKeys\": selectedKeys => true,\n    \"check\": (checkedKeys, data) => true,\n    \"update:checkedKeys\": checkedKeys => true,\n    \"update:halfCheckedKeys\": halfCheckedKeys => true,\n    \"expand\": (expandKeys, data) => true,\n    \"update:expandedKeys\": expandKeys => true,\n    \"dragStart\": (ev, node) => true,\n    \"dragEnd\": (ev, node) => true,\n    \"dragOver\": (ev, node) => true,\n    \"dragLeave\": (ev, node) => true,\n    \"drop\": data => true\n  },\n\n  setup(props, {\n    emit,\n    slots\n  }) {\n    const {\n      data: propTreeData,\n      showLine,\n      multiple,\n      loadMore,\n      checkStrictly,\n      checkedKeys: propCheckedKeys,\n      defaultCheckedKeys,\n      selectedKeys: propSelectedKeys,\n      defaultSelectedKeys,\n      expandedKeys: propExpandedKeys,\n      defaultExpandedKeys,\n      checkedStrategy,\n      selectable,\n      checkable,\n      blockNode,\n      fieldNames,\n      size,\n      defaultExpandAll,\n      filterTreeNode,\n      draggable,\n      allowDrop,\n      defaultExpandSelected,\n      defaultExpandChecked,\n      autoExpandParent,\n      halfCheckedKeys,\n      onlyCheckLeaf,\n      animation\n    } = toRefs(props);\n    const prefixCls = getPrefixCls(\"tree\");\n    const classNames = computed(() => [`${prefixCls}`, {\n      [`${prefixCls}-checkable`]: checkable.value,\n      [`${prefixCls}-show-line`]: showLine.value\n    }, `${prefixCls}-size-${size.value}`]);\n    const switcherIcon = usePickSlots(slots, \"switcher-icon\");\n    const loadingIcon = usePickSlots(slots, \"loading-icon\");\n    const dragIcon = usePickSlots(slots, \"drag-icon\");\n    const nodeIcon = usePickSlots(slots, \"icon\");\n    const nodeTitle = usePickSlots(slots, \"title\");\n    const nodeExtra = usePickSlots(slots, \"extra\");\n    const {\n      treeData,\n      flattenTreeData,\n      key2TreeNode\n    } = useTreeData(reactive({\n      treeData: propTreeData,\n      selectable,\n      showLine,\n      blockNode,\n      checkable,\n      fieldNames,\n      loadMore,\n      draggable\n    }));\n    const {\n      checkedKeys,\n      indeterminateKeys,\n      setCheckedState\n    } = useCheckedState(reactive({\n      defaultCheckedKeys,\n      checkedKeys: propCheckedKeys,\n      checkStrictly,\n      key2TreeNode,\n      halfCheckedKeys,\n      onlyCheckLeaf\n    }));\n    const [selectedKeys, setSelectedState] = useMergeState((defaultSelectedKeys == null ? void 0 : defaultSelectedKeys.value) || [], reactive({\n      value: propSelectedKeys\n    }));\n    const loadingKeys = ref([]);\n    const dragNode = ref();\n\n    function getDefaultExpandedKeys() {\n      if (defaultExpandedKeys == null ? void 0 : defaultExpandedKeys.value) {\n        const expandedKeysSet = new Set([]);\n        defaultExpandedKeys.value.forEach(_key => {\n          if (expandedKeysSet.has(_key)) return;\n          const node = key2TreeNode.value.get(_key);\n          if (!node) return;\n          [...(autoExpandParent.value ? node.pathParentKeys : []), _key].forEach(_key2 => expandedKeysSet.add(_key2));\n        });\n        return [...expandedKeysSet];\n      }\n\n      if (defaultExpandAll.value) {\n        return flattenTreeData.value.filter(node => node.children && node.children.length).map(node => node.key);\n      }\n\n      if (defaultExpandSelected.value || defaultExpandChecked.value) {\n        const expandedKeysSet = new Set([]);\n\n        const addToExpandKeysSet = keys => {\n          keys.forEach(key => {\n            const node = key2TreeNode.value.get(key);\n            if (!node) return;\n            (node.pathParentKeys || []).forEach(k => expandedKeysSet.add(k));\n          });\n        };\n\n        if (defaultExpandSelected.value) {\n          addToExpandKeysSet(selectedKeys.value);\n        }\n\n        if (defaultExpandChecked.value) {\n          addToExpandKeysSet(checkedKeys.value);\n        }\n\n        return [...expandedKeysSet];\n      }\n\n      return [];\n    }\n\n    const [expandedKeys, setExpandState] = useMergeState(getDefaultExpandedKeys(), reactive({\n      value: propExpandedKeys\n    }));\n    const currentExpandKeys = ref([]);\n    const visibleTreeNodeList = computed(() => {\n      const expandedKeysSet = new Set(expandedKeys.value);\n      const currentExpandKeysSet = new Set(currentExpandKeys.value);\n      return flattenTreeData.value.filter(node => {\n        var _a;\n\n        const passFilter = !filterTreeNode || !filterTreeNode.value || (filterTreeNode == null ? void 0 : filterTreeNode.value(node.treeNodeData));\n        if (!passFilter) return false;\n        const isRoot = isUndefined(node.parentKey);\n        const isVisibleNode = (_a = node.pathParentKeys) == null ? void 0 : _a.every(_key => expandedKeysSet.has(_key) && !currentExpandKeysSet.has(_key));\n        return isRoot || isVisibleNode;\n      });\n    });\n\n    function getPublicCheckedKeys(rawCheckedKeys, rawCheckedStrategy = checkedStrategy.value) {\n      let publicCheckedKeys = [...rawCheckedKeys];\n\n      if (rawCheckedStrategy === \"parent\") {\n        publicCheckedKeys = rawCheckedKeys.filter(_key => {\n          const item = key2TreeNode.value.get(_key);\n          return item && !(!isUndefined(item.parentKey) && rawCheckedKeys.includes(item.parentKey));\n        });\n      } else if (rawCheckedStrategy === \"child\") {\n        publicCheckedKeys = rawCheckedKeys.filter(_key => {\n          var _a, _b;\n\n          return !((_b = (_a = key2TreeNode.value.get(_key)) == null ? void 0 : _a.children) == null ? void 0 : _b.length);\n        });\n      }\n\n      return publicCheckedKeys;\n    }\n\n    function getNodes(keys) {\n      return keys.map(key => {\n        var _a;\n\n        return ((_a = key2TreeNode.value.get(key)) == null ? void 0 : _a.treeNodeData) || void 0;\n      }).filter(Boolean);\n    }\n\n    function emitCheckEvent(options) {\n      const {\n        targetKey,\n        targetChecked,\n        newCheckedKeys,\n        newIndeterminateKeys,\n        event\n      } = options;\n      const targetNode = targetKey ? key2TreeNode.value.get(targetKey) : void 0;\n      const publicCheckedKeys = getPublicCheckedKeys(newCheckedKeys);\n      emit(\"check\", publicCheckedKeys, {\n        checked: targetChecked,\n        node: targetNode == null ? void 0 : targetNode.treeNodeData,\n        checkedNodes: getNodes(publicCheckedKeys),\n        halfCheckedKeys: newIndeterminateKeys,\n        halfCheckedNodes: getNodes(newIndeterminateKeys),\n        e: event\n      });\n      emit(\"update:checkedKeys\", publicCheckedKeys);\n      emit(\"update:halfCheckedKeys\", newIndeterminateKeys);\n    }\n\n    function emitSelectEvent(options) {\n      const {\n        targetKey,\n        targetSelected,\n        newSelectedKeys,\n        event\n      } = options;\n      const targetNode = targetKey ? key2TreeNode.value.get(targetKey) : void 0;\n      emit(\"select\", newSelectedKeys, {\n        selected: targetSelected,\n        node: targetNode == null ? void 0 : targetNode.treeNodeData,\n        selectedNodes: getNodes(newSelectedKeys),\n        e: event\n      });\n      emit(\"update:selectedKeys\", newSelectedKeys);\n    }\n\n    function emitExpandEvent(options) {\n      const {\n        targetKey,\n        targetExpanded,\n        newExpandedKeys,\n        event\n      } = options;\n      const targetNode = targetKey ? key2TreeNode.value.get(targetKey) : void 0;\n      emit(\"expand\", newExpandedKeys, {\n        expanded: targetExpanded,\n        node: targetNode == null ? void 0 : targetNode.treeNodeData,\n        expandedNodes: getNodes(newExpandedKeys),\n        e: event\n      });\n      emit(\"update:expandedKeys\", newExpandedKeys);\n    }\n\n    function setCheckedKeys(keys) {\n      const [newCheckedKeys, newIndeterminateKeys] = setCheckedState(keys, [], true);\n      emitCheckEvent({\n        newCheckedKeys,\n        newIndeterminateKeys\n      });\n    }\n\n    function setSelectedKeys(keys) {\n      let newSelectedKeys = keys;\n\n      if (!multiple.value && keys.length > 1) {\n        newSelectedKeys = [keys[0]];\n      }\n\n      setSelectedState(newSelectedKeys);\n      emitSelectEvent({\n        newSelectedKeys\n      });\n    }\n\n    function setExpandedKeys(keys) {\n      currentExpandKeys.value = [];\n      setExpandState(keys);\n      emitExpandEvent({\n        newExpandedKeys: keys\n      });\n    }\n\n    function checkNodes(keys, checked, targetKey) {\n      if (!keys.length) return;\n      let newCheckedKeys = [...checkedKeys.value];\n      let newIndeterminateKeys = [...indeterminateKeys.value];\n      keys.forEach(key => {\n        const node = key2TreeNode.value.get(key);\n\n        if (node) {\n          [newCheckedKeys, newIndeterminateKeys] = getCheckedStateByCheck({\n            node,\n            checked,\n            checkedKeys: [...newCheckedKeys],\n            indeterminateKeys: [...newIndeterminateKeys],\n            checkStrictly: checkStrictly.value\n          });\n        }\n      });\n      setCheckedState(newCheckedKeys, newIndeterminateKeys);\n      emitCheckEvent({\n        targetKey,\n        targetChecked: isUndefined(targetKey) ? void 0 : checked,\n        newCheckedKeys,\n        newIndeterminateKeys\n      });\n    }\n\n    function selectNodes(keys, selected, targetKey) {\n      if (!keys.length) return;\n      let newSelectedKeys;\n\n      if (multiple.value) {\n        const selectedKeysSet = new Set(selectedKeys.value);\n        keys.forEach(key => {\n          selected ? selectedKeysSet.add(key) : selectedKeysSet.delete(key);\n        });\n        newSelectedKeys = [...selectedKeysSet];\n      } else {\n        newSelectedKeys = selected ? [keys[0]] : [];\n      }\n\n      setSelectedState(newSelectedKeys);\n      emitSelectEvent({\n        targetKey,\n        targetSelected: isUndefined(targetKey) ? void 0 : selected,\n        newSelectedKeys\n      });\n    }\n\n    function expandNodes(keys, expanded, targetKey) {\n      const expandedKeysSet = new Set(expandedKeys.value);\n      keys.forEach(key => {\n        expanded ? expandedKeysSet.add(key) : expandedKeysSet.delete(key);\n        onExpandEnd(key);\n      });\n      const newExpandedKeys = [...expandedKeysSet];\n      setExpandState(newExpandedKeys);\n      emitExpandEvent({\n        targetKey,\n        targetExpanded: isUndefined(targetKey) ? void 0 : expanded,\n        newExpandedKeys\n      });\n    }\n\n    function onCheck(checked, key, e) {\n      const node = key2TreeNode.value.get(key);\n      if (!node) return;\n      const [newCheckedKeys, newIndeterminateKeys] = getCheckedStateByCheck({\n        node,\n        checked,\n        checkedKeys: checkedKeys.value,\n        indeterminateKeys: indeterminateKeys.value,\n        checkStrictly: checkStrictly.value\n      });\n      setCheckedState(newCheckedKeys, newIndeterminateKeys);\n      emitCheckEvent({\n        targetKey: key,\n        targetChecked: checked,\n        newCheckedKeys,\n        newIndeterminateKeys,\n        event: e\n      });\n    }\n\n    function onSelect(key, e) {\n      const node = key2TreeNode.value.get(key);\n      if (!node) return;\n      let newSelectedKeys;\n      let selected;\n\n      if (multiple.value) {\n        const selectedKeysSet = new Set(selectedKeys.value);\n        selected = !selectedKeysSet.has(key);\n        selected ? selectedKeysSet.add(key) : selectedKeysSet.delete(key);\n        newSelectedKeys = [...selectedKeysSet];\n      } else {\n        selected = true;\n        newSelectedKeys = [key];\n      }\n\n      setSelectedState(newSelectedKeys);\n      emitSelectEvent({\n        targetKey: key,\n        targetSelected: selected,\n        newSelectedKeys,\n        event: e\n      });\n    }\n\n    function onExpand(expanded, key, e) {\n      if (currentExpandKeys.value.includes(key)) return;\n      const node = key2TreeNode.value.get(key);\n      if (!node) return;\n      const expandedKeysSet = new Set(expandedKeys.value);\n      expanded ? expandedKeysSet.add(key) : expandedKeysSet.delete(key);\n      const newExpandedKeys = [...expandedKeysSet];\n      setExpandState(newExpandedKeys);\n\n      if (animation.value) {\n        currentExpandKeys.value.push(key);\n      }\n\n      emitExpandEvent({\n        targetKey: key,\n        targetExpanded: expanded,\n        newExpandedKeys,\n        event: e\n      });\n    }\n\n    function onExpandEnd(key) {\n      const index = currentExpandKeys.value.indexOf(key);\n      currentExpandKeys.value.splice(index, 1);\n    }\n\n    const onLoadMore = computed(() => (loadMore == null ? void 0 : loadMore.value) ? async key => {\n      if (!isFunction(loadMore.value)) return;\n      const node = key2TreeNode.value.get(key);\n      if (!node) return;\n      const {\n        treeNodeData\n      } = node;\n      loadingKeys.value = [...new Set([...loadingKeys.value, key])];\n\n      try {\n        await loadMore.value(treeNodeData);\n        loadingKeys.value = loadingKeys.value.filter(v => v !== key);\n        onExpand(true, key);\n\n        if (checkedKeys.value.includes(key)) {\n          onCheck(true, key);\n        }\n      } catch (err) {\n        loadingKeys.value = loadingKeys.value.filter(v => v !== key);\n        console.error(\"[tree]load data error: \", err);\n      }\n    } : void 0);\n    const treeContext = reactive({\n      treeProps: props,\n      switcherIcon,\n      loadingIcon,\n      dragIcon,\n      nodeIcon,\n      nodeTitle,\n      nodeExtra,\n      treeData,\n      flattenTreeData,\n      key2TreeNode,\n      checkedKeys,\n      indeterminateKeys,\n      selectedKeys,\n      expandedKeys,\n      loadingKeys,\n      currentExpandKeys,\n      onLoadMore,\n      filterTreeNode,\n      onCheck,\n      onSelect,\n      onExpand,\n      onExpandEnd,\n\n      allowDrop(key, dropPosition) {\n        const node = key2TreeNode.value.get(key);\n\n        if (node && isFunction(allowDrop.value)) {\n          return !!allowDrop.value({\n            dropNode: node.treeNodeData,\n            dropPosition\n          });\n        }\n\n        return true;\n      },\n\n      onDragStart(key, e) {\n        const node = key2TreeNode.value.get(key);\n        dragNode.value = node;\n\n        if (node) {\n          emit(\"dragStart\", e, node.treeNodeData);\n        }\n      },\n\n      onDragEnd(key, e) {\n        const node = key2TreeNode.value.get(key);\n        dragNode.value = void 0;\n\n        if (node) {\n          emit(\"dragEnd\", e, node.treeNodeData);\n        }\n      },\n\n      onDragOver(key, e) {\n        const node = key2TreeNode.value.get(key);\n\n        if (node) {\n          emit(\"dragOver\", e, node.treeNodeData);\n        }\n      },\n\n      onDragLeave(key, e) {\n        const node = key2TreeNode.value.get(key);\n\n        if (node) {\n          emit(\"dragLeave\", e, node.treeNodeData);\n        }\n      },\n\n      onDrop(key, dropPosition, e) {\n        const node = key2TreeNode.value.get(key);\n\n        if (dragNode.value && node && !(node.key === dragNode.value.key || node.pathParentKeys.includes(dragNode.value.key || \"\"))) {\n          emit(\"drop\", {\n            e,\n            dragNode: dragNode.value.treeNodeData,\n            dropNode: node.treeNodeData,\n            dropPosition\n          });\n        }\n      }\n\n    });\n    provide(TreeInjectionKey, treeContext);\n    return {\n      classNames,\n      visibleTreeNodeList,\n      treeContext,\n      virtualListRef: ref(),\n      computedSelectedKeys: selectedKeys,\n      computedExpandedKeys: expandedKeys,\n      computedCheckedKeys: checkedKeys,\n      computedIndeterminateKeys: indeterminateKeys,\n      getPublicCheckedKeys,\n      getNodes,\n      internalCheckNodes: checkNodes,\n      internalSetCheckedKeys: setCheckedKeys,\n      internalSelectNodes: selectNodes,\n      internalSetSelectedKeys: setSelectedKeys,\n      internalExpandNodes: expandNodes,\n      internalSetExpandedKeys: setExpandedKeys\n    };\n  },\n\n  methods: {\n    toggleCheck(key, e) {\n      const {\n        key2TreeNode,\n        onCheck,\n        checkedKeys\n      } = this.treeContext;\n      const checked = !checkedKeys.includes(key);\n      const node = key2TreeNode.get(key);\n\n      if (node && isNodeCheckable(node)) {\n        onCheck(checked, key, e);\n      }\n    },\n\n    scrollIntoView(options) {\n      this.virtualListRef && this.virtualListRef.scrollTo(options);\n    },\n\n    getSelectedNodes() {\n      return this.getNodes(this.computedSelectedKeys);\n    },\n\n    getCheckedNodes(options = {}) {\n      const {\n        checkedStrategy,\n        includeHalfChecked\n      } = options;\n      const checkedKeys = this.getPublicCheckedKeys(this.computedCheckedKeys, checkedStrategy);\n      const checkedNodes = this.getNodes(checkedKeys);\n      return [...checkedNodes, ...(includeHalfChecked ? this.getHalfCheckedNodes() : [])];\n    },\n\n    getHalfCheckedNodes() {\n      return this.getNodes(this.computedIndeterminateKeys);\n    },\n\n    getExpandedNodes() {\n      return this.getNodes(this.computedExpandedKeys);\n    },\n\n    checkAll(checked = true) {\n      const {\n        key2TreeNode\n      } = this.treeContext;\n      const newKeys = checked ? [...key2TreeNode.keys()].filter(key => {\n        const node = key2TreeNode.get(key);\n        return node && isNodeCheckable(node);\n      }) : [];\n      this.internalSetCheckedKeys(newKeys);\n    },\n\n    checkNode(key, checked = true, onlyCheckLeaf = false) {\n      const {\n        checkStrictly,\n        treeContext\n      } = this;\n      const {\n        key2TreeNode\n      } = treeContext;\n      const isBatch = isArray(key);\n      const keys = (isBatch ? key : [key]).filter(key2 => {\n        const node = key2TreeNode.get(key2);\n        return node && isNodeCheckable(node) && (checkStrictly || !onlyCheckLeaf || isLeafNode(node));\n      });\n      this.internalCheckNodes(keys, checked, isBatch ? void 0 : key);\n    },\n\n    selectAll(selected = true) {\n      const {\n        key2TreeNode\n      } = this.treeContext;\n      const newKeys = selected ? [...key2TreeNode.keys()].filter(key => {\n        const node = key2TreeNode.get(key);\n        return node && isNodeSelectable(node);\n      }) : [];\n      this.internalSetSelectedKeys(newKeys);\n    },\n\n    selectNode(key, selected = true) {\n      const {\n        key2TreeNode\n      } = this.treeContext;\n      const isBatch = isArray(key);\n      const keys = (isBatch ? key : [key]).filter(key2 => {\n        const node = key2TreeNode.get(key2);\n        return node && isNodeSelectable(node);\n      });\n      this.internalSelectNodes(keys, selected, isBatch ? void 0 : key);\n    },\n\n    expandAll(expanded = true) {\n      const {\n        key2TreeNode\n      } = this.treeContext;\n      const newKeys = expanded ? [...key2TreeNode.keys()].filter(key => {\n        const node = key2TreeNode.get(key);\n        return node && isNodeExpandable(node);\n      }) : [];\n      this.internalSetExpandedKeys(newKeys);\n    },\n\n    expandNode(key, expanded = true) {\n      const {\n        key2TreeNode\n      } = this.treeContext;\n      const isBatch = isArray(key);\n      const keys = (isBatch ? key : [key]).filter(key2 => {\n        const node = key2TreeNode.get(key2);\n        return node && isNodeExpandable(node);\n      });\n      this.internalExpandNodes(keys, expanded, isBatch ? void 0 : key);\n    }\n\n  }\n});\n\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_TreeNode = resolveComponent(\"TreeNode\");\n\n  const _component_VirtualList = resolveComponent(\"VirtualList\");\n\n  return openBlock(), createElementBlock(\"div\", {\n    class: normalizeClass(_ctx.classNames)\n  }, [_ctx.virtualListProps ? (openBlock(), createBlock(_component_VirtualList, mergeProps({\n    key: 0,\n    ref: \"virtualListRef\"\n  }, _ctx.virtualListProps, {\n    data: _ctx.visibleTreeNodeList\n  }), {\n    item: withCtx(({\n      item: node\n    }) => [createVNode(_component_TreeNode, mergeProps({\n      key: node.key\n    }, node.treeNodeProps), null, 16)]),\n    _: 1\n  }, 16, [\"data\"])) : (openBlock(true), createElementBlock(Fragment, {\n    key: 1\n  }, renderList(_ctx.visibleTreeNodeList, node => {\n    return openBlock(), createBlock(_component_TreeNode, mergeProps({\n      key: node.key\n    }, node.treeNodeProps), null, 16);\n  }), 128))], 2);\n}\n\nvar _Tree = /* @__PURE__ */_export_sfc(_sfc_main, [[\"render\", _sfc_render]]);\n\nexport { _Tree as default };","map":{"version":3,"names":["defineComponent","toRefs","computed","reactive","ref","provide","resolveComponent","openBlock","createElementBlock","normalizeClass","createBlock","mergeProps","withCtx","createVNode","Fragment","renderList","getPrefixCls","TreeInjectionKey","usePickSlots","isLeafNode","isNodeSelectable","isNodeExpandable","isNodeCheckable","getCheckedStateByCheck","TreeNode","isUndefined","isFunction","isArray","useMergeState","useCheckedState","useTreeData","VirtualList","_export_sfc","_sfc_main","name","components","props","size","type","String","default","blockNode","Boolean","defaultExpandAll","multiple","checkable","Function","selectable","checkStrictly","checkedStrategy","defaultSelectedKeys","Array","selectedKeys","defaultCheckedKeys","checkedKeys","defaultExpandedKeys","expandedKeys","data","fieldNames","Object","showLine","loadMore","draggable","allowDrop","filterTreeNode","virtualListProps","defaultExpandSelected","defaultExpandChecked","autoExpandParent","halfCheckedKeys","onlyCheckLeaf","animation","actionOnNodeClick","disableSelectActionOnly","emits","expandKeys","ev","node","setup","emit","slots","propTreeData","propCheckedKeys","propSelectedKeys","propExpandedKeys","prefixCls","classNames","value","switcherIcon","loadingIcon","dragIcon","nodeIcon","nodeTitle","nodeExtra","treeData","flattenTreeData","key2TreeNode","indeterminateKeys","setCheckedState","setSelectedState","loadingKeys","dragNode","getDefaultExpandedKeys","expandedKeysSet","Set","forEach","_key","has","get","pathParentKeys","_key2","add","filter","children","length","map","key","addToExpandKeysSet","keys","k","setExpandState","currentExpandKeys","visibleTreeNodeList","currentExpandKeysSet","_a","passFilter","treeNodeData","isRoot","parentKey","isVisibleNode","every","getPublicCheckedKeys","rawCheckedKeys","rawCheckedStrategy","publicCheckedKeys","item","includes","_b","getNodes","emitCheckEvent","options","targetKey","targetChecked","newCheckedKeys","newIndeterminateKeys","event","targetNode","checked","checkedNodes","halfCheckedNodes","e","emitSelectEvent","targetSelected","newSelectedKeys","selected","selectedNodes","emitExpandEvent","targetExpanded","newExpandedKeys","expanded","expandedNodes","setCheckedKeys","setSelectedKeys","setExpandedKeys","checkNodes","selectNodes","selectedKeysSet","delete","expandNodes","onExpandEnd","onCheck","onSelect","onExpand","push","index","indexOf","splice","onLoadMore","v","err","console","error","treeContext","treeProps","dropPosition","dropNode","onDragStart","onDragEnd","onDragOver","onDragLeave","onDrop","virtualListRef","computedSelectedKeys","computedExpandedKeys","computedCheckedKeys","computedIndeterminateKeys","internalCheckNodes","internalSetCheckedKeys","internalSelectNodes","internalSetSelectedKeys","internalExpandNodes","internalSetExpandedKeys","methods","toggleCheck","scrollIntoView","scrollTo","getSelectedNodes","getCheckedNodes","includeHalfChecked","getHalfCheckedNodes","getExpandedNodes","checkAll","newKeys","checkNode","isBatch","key2","selectAll","selectNode","expandAll","expandNode","_sfc_render","_ctx","_cache","$props","$setup","$data","$options","_component_TreeNode","_component_VirtualList","class","treeNodeProps","_","_Tree"],"sources":["/www/wwwroot/admin/node_modules/@arco-design/web-vue/es/tree/tree.js"],"sourcesContent":["import { defineComponent, toRefs, computed, reactive, ref, provide, resolveComponent, openBlock, createElementBlock, normalizeClass, createBlock, mergeProps, withCtx, createVNode, Fragment, renderList } from \"vue\";\nimport { getPrefixCls } from \"../_utils/global-config.js\";\nimport { TreeInjectionKey } from \"./context.js\";\nimport usePickSlots from \"../_hooks/use-pick-slots.js\";\nimport { isLeafNode, isNodeSelectable, isNodeExpandable } from \"./utils/index.js\";\nimport { isNodeCheckable, getCheckedStateByCheck } from \"./utils/check-utils.js\";\nimport TreeNode from \"./node.js\";\nimport { isUndefined, isFunction, isArray } from \"../_utils/is.js\";\nimport useMergeState from \"../_hooks/use-merge-state.js\";\nimport useCheckedState from \"./hooks/use-checked-state.js\";\nimport useTreeData from \"./hooks/use-tree-data.js\";\nimport VirtualList from \"../_components/virtual-list/virtual-list.js\";\nimport _export_sfc from \"../_virtual/plugin-vue_export-helper.js\";\nconst _sfc_main = defineComponent({\n  name: \"Tree\",\n  components: {\n    VirtualList,\n    TreeNode\n  },\n  props: {\n    size: {\n      type: String,\n      default: \"medium\"\n    },\n    blockNode: {\n      type: Boolean\n    },\n    defaultExpandAll: {\n      type: Boolean,\n      default: true\n    },\n    multiple: {\n      type: Boolean\n    },\n    checkable: {\n      type: [Boolean, String, Function],\n      default: false\n    },\n    selectable: {\n      type: [Boolean, Function],\n      default: true\n    },\n    checkStrictly: {\n      type: Boolean\n    },\n    checkedStrategy: {\n      type: String,\n      default: \"all\"\n    },\n    defaultSelectedKeys: {\n      type: Array\n    },\n    selectedKeys: {\n      type: Array\n    },\n    defaultCheckedKeys: {\n      type: Array\n    },\n    checkedKeys: {\n      type: Array\n    },\n    defaultExpandedKeys: {\n      type: Array\n    },\n    expandedKeys: {\n      type: Array\n    },\n    data: {\n      type: Array,\n      default: () => []\n    },\n    fieldNames: {\n      type: Object\n    },\n    showLine: {\n      type: Boolean\n    },\n    loadMore: {\n      type: Function\n    },\n    draggable: {\n      type: Boolean\n    },\n    allowDrop: {\n      type: Function\n    },\n    filterTreeNode: {\n      type: Function\n    },\n    virtualListProps: {\n      type: Object\n    },\n    defaultExpandSelected: {\n      type: Boolean\n    },\n    defaultExpandChecked: {\n      type: Boolean\n    },\n    autoExpandParent: {\n      type: Boolean,\n      default: true\n    },\n    halfCheckedKeys: {\n      type: Array\n    },\n    onlyCheckLeaf: {\n      type: Boolean,\n      default: false\n    },\n    animation: {\n      type: Boolean,\n      default: true\n    },\n    actionOnNodeClick: {\n      type: String\n    },\n    disableSelectActionOnly: {\n      type: Boolean,\n      default: false\n    }\n  },\n  emits: {\n    \"select\": (selectedKeys, data) => true,\n    \"update:selectedKeys\": (selectedKeys) => true,\n    \"check\": (checkedKeys, data) => true,\n    \"update:checkedKeys\": (checkedKeys) => true,\n    \"update:halfCheckedKeys\": (halfCheckedKeys) => true,\n    \"expand\": (expandKeys, data) => true,\n    \"update:expandedKeys\": (expandKeys) => true,\n    \"dragStart\": (ev, node) => true,\n    \"dragEnd\": (ev, node) => true,\n    \"dragOver\": (ev, node) => true,\n    \"dragLeave\": (ev, node) => true,\n    \"drop\": (data) => true\n  },\n  setup(props, { emit, slots }) {\n    const {\n      data: propTreeData,\n      showLine,\n      multiple,\n      loadMore,\n      checkStrictly,\n      checkedKeys: propCheckedKeys,\n      defaultCheckedKeys,\n      selectedKeys: propSelectedKeys,\n      defaultSelectedKeys,\n      expandedKeys: propExpandedKeys,\n      defaultExpandedKeys,\n      checkedStrategy,\n      selectable,\n      checkable,\n      blockNode,\n      fieldNames,\n      size,\n      defaultExpandAll,\n      filterTreeNode,\n      draggable,\n      allowDrop,\n      defaultExpandSelected,\n      defaultExpandChecked,\n      autoExpandParent,\n      halfCheckedKeys,\n      onlyCheckLeaf,\n      animation\n    } = toRefs(props);\n    const prefixCls = getPrefixCls(\"tree\");\n    const classNames = computed(() => [\n      `${prefixCls}`,\n      {\n        [`${prefixCls}-checkable`]: checkable.value,\n        [`${prefixCls}-show-line`]: showLine.value\n      },\n      `${prefixCls}-size-${size.value}`\n    ]);\n    const switcherIcon = usePickSlots(slots, \"switcher-icon\");\n    const loadingIcon = usePickSlots(slots, \"loading-icon\");\n    const dragIcon = usePickSlots(slots, \"drag-icon\");\n    const nodeIcon = usePickSlots(slots, \"icon\");\n    const nodeTitle = usePickSlots(slots, \"title\");\n    const nodeExtra = usePickSlots(slots, \"extra\");\n    const { treeData, flattenTreeData, key2TreeNode } = useTreeData(reactive({\n      treeData: propTreeData,\n      selectable,\n      showLine,\n      blockNode,\n      checkable,\n      fieldNames,\n      loadMore,\n      draggable\n    }));\n    const { checkedKeys, indeterminateKeys, setCheckedState } = useCheckedState(reactive({\n      defaultCheckedKeys,\n      checkedKeys: propCheckedKeys,\n      checkStrictly,\n      key2TreeNode,\n      halfCheckedKeys,\n      onlyCheckLeaf\n    }));\n    const [selectedKeys, setSelectedState] = useMergeState((defaultSelectedKeys == null ? void 0 : defaultSelectedKeys.value) || [], reactive({\n      value: propSelectedKeys\n    }));\n    const loadingKeys = ref([]);\n    const dragNode = ref();\n    function getDefaultExpandedKeys() {\n      if (defaultExpandedKeys == null ? void 0 : defaultExpandedKeys.value) {\n        const expandedKeysSet = new Set([]);\n        defaultExpandedKeys.value.forEach((_key) => {\n          if (expandedKeysSet.has(_key))\n            return;\n          const node = key2TreeNode.value.get(_key);\n          if (!node)\n            return;\n          [\n            ...autoExpandParent.value ? node.pathParentKeys : [],\n            _key\n          ].forEach((_key2) => expandedKeysSet.add(_key2));\n        });\n        return [...expandedKeysSet];\n      }\n      if (defaultExpandAll.value) {\n        return flattenTreeData.value.filter((node) => node.children && node.children.length).map((node) => node.key);\n      }\n      if (defaultExpandSelected.value || defaultExpandChecked.value) {\n        const expandedKeysSet = new Set([]);\n        const addToExpandKeysSet = (keys) => {\n          keys.forEach((key) => {\n            const node = key2TreeNode.value.get(key);\n            if (!node)\n              return;\n            (node.pathParentKeys || []).forEach((k) => expandedKeysSet.add(k));\n          });\n        };\n        if (defaultExpandSelected.value) {\n          addToExpandKeysSet(selectedKeys.value);\n        }\n        if (defaultExpandChecked.value) {\n          addToExpandKeysSet(checkedKeys.value);\n        }\n        return [...expandedKeysSet];\n      }\n      return [];\n    }\n    const [expandedKeys, setExpandState] = useMergeState(getDefaultExpandedKeys(), reactive({\n      value: propExpandedKeys\n    }));\n    const currentExpandKeys = ref([]);\n    const visibleTreeNodeList = computed(() => {\n      const expandedKeysSet = new Set(expandedKeys.value);\n      const currentExpandKeysSet = new Set(currentExpandKeys.value);\n      return flattenTreeData.value.filter((node) => {\n        var _a;\n        const passFilter = !filterTreeNode || !filterTreeNode.value || (filterTreeNode == null ? void 0 : filterTreeNode.value(node.treeNodeData));\n        if (!passFilter)\n          return false;\n        const isRoot = isUndefined(node.parentKey);\n        const isVisibleNode = (_a = node.pathParentKeys) == null ? void 0 : _a.every((_key) => expandedKeysSet.has(_key) && !currentExpandKeysSet.has(_key));\n        return isRoot || isVisibleNode;\n      });\n    });\n    function getPublicCheckedKeys(rawCheckedKeys, rawCheckedStrategy = checkedStrategy.value) {\n      let publicCheckedKeys = [...rawCheckedKeys];\n      if (rawCheckedStrategy === \"parent\") {\n        publicCheckedKeys = rawCheckedKeys.filter((_key) => {\n          const item = key2TreeNode.value.get(_key);\n          return item && !(!isUndefined(item.parentKey) && rawCheckedKeys.includes(item.parentKey));\n        });\n      } else if (rawCheckedStrategy === \"child\") {\n        publicCheckedKeys = rawCheckedKeys.filter((_key) => {\n          var _a, _b;\n          return !((_b = (_a = key2TreeNode.value.get(_key)) == null ? void 0 : _a.children) == null ? void 0 : _b.length);\n        });\n      }\n      return publicCheckedKeys;\n    }\n    function getNodes(keys) {\n      return keys.map((key) => {\n        var _a;\n        return ((_a = key2TreeNode.value.get(key)) == null ? void 0 : _a.treeNodeData) || void 0;\n      }).filter(Boolean);\n    }\n    function emitCheckEvent(options) {\n      const {\n        targetKey,\n        targetChecked,\n        newCheckedKeys,\n        newIndeterminateKeys,\n        event\n      } = options;\n      const targetNode = targetKey ? key2TreeNode.value.get(targetKey) : void 0;\n      const publicCheckedKeys = getPublicCheckedKeys(newCheckedKeys);\n      emit(\"check\", publicCheckedKeys, {\n        checked: targetChecked,\n        node: targetNode == null ? void 0 : targetNode.treeNodeData,\n        checkedNodes: getNodes(publicCheckedKeys),\n        halfCheckedKeys: newIndeterminateKeys,\n        halfCheckedNodes: getNodes(newIndeterminateKeys),\n        e: event\n      });\n      emit(\"update:checkedKeys\", publicCheckedKeys);\n      emit(\"update:halfCheckedKeys\", newIndeterminateKeys);\n    }\n    function emitSelectEvent(options) {\n      const { targetKey, targetSelected, newSelectedKeys, event } = options;\n      const targetNode = targetKey ? key2TreeNode.value.get(targetKey) : void 0;\n      emit(\"select\", newSelectedKeys, {\n        selected: targetSelected,\n        node: targetNode == null ? void 0 : targetNode.treeNodeData,\n        selectedNodes: getNodes(newSelectedKeys),\n        e: event\n      });\n      emit(\"update:selectedKeys\", newSelectedKeys);\n    }\n    function emitExpandEvent(options) {\n      const { targetKey, targetExpanded, newExpandedKeys, event } = options;\n      const targetNode = targetKey ? key2TreeNode.value.get(targetKey) : void 0;\n      emit(\"expand\", newExpandedKeys, {\n        expanded: targetExpanded,\n        node: targetNode == null ? void 0 : targetNode.treeNodeData,\n        expandedNodes: getNodes(newExpandedKeys),\n        e: event\n      });\n      emit(\"update:expandedKeys\", newExpandedKeys);\n    }\n    function setCheckedKeys(keys) {\n      const [newCheckedKeys, newIndeterminateKeys] = setCheckedState(keys, [], true);\n      emitCheckEvent({ newCheckedKeys, newIndeterminateKeys });\n    }\n    function setSelectedKeys(keys) {\n      let newSelectedKeys = keys;\n      if (!multiple.value && keys.length > 1) {\n        newSelectedKeys = [keys[0]];\n      }\n      setSelectedState(newSelectedKeys);\n      emitSelectEvent({\n        newSelectedKeys\n      });\n    }\n    function setExpandedKeys(keys) {\n      currentExpandKeys.value = [];\n      setExpandState(keys);\n      emitExpandEvent({ newExpandedKeys: keys });\n    }\n    function checkNodes(keys, checked, targetKey) {\n      if (!keys.length)\n        return;\n      let newCheckedKeys = [...checkedKeys.value];\n      let newIndeterminateKeys = [...indeterminateKeys.value];\n      keys.forEach((key) => {\n        const node = key2TreeNode.value.get(key);\n        if (node) {\n          [newCheckedKeys, newIndeterminateKeys] = getCheckedStateByCheck({\n            node,\n            checked,\n            checkedKeys: [...newCheckedKeys],\n            indeterminateKeys: [...newIndeterminateKeys],\n            checkStrictly: checkStrictly.value\n          });\n        }\n      });\n      setCheckedState(newCheckedKeys, newIndeterminateKeys);\n      emitCheckEvent({\n        targetKey,\n        targetChecked: isUndefined(targetKey) ? void 0 : checked,\n        newCheckedKeys,\n        newIndeterminateKeys\n      });\n    }\n    function selectNodes(keys, selected, targetKey) {\n      if (!keys.length)\n        return;\n      let newSelectedKeys;\n      if (multiple.value) {\n        const selectedKeysSet = new Set(selectedKeys.value);\n        keys.forEach((key) => {\n          selected ? selectedKeysSet.add(key) : selectedKeysSet.delete(key);\n        });\n        newSelectedKeys = [...selectedKeysSet];\n      } else {\n        newSelectedKeys = selected ? [keys[0]] : [];\n      }\n      setSelectedState(newSelectedKeys);\n      emitSelectEvent({\n        targetKey,\n        targetSelected: isUndefined(targetKey) ? void 0 : selected,\n        newSelectedKeys\n      });\n    }\n    function expandNodes(keys, expanded, targetKey) {\n      const expandedKeysSet = new Set(expandedKeys.value);\n      keys.forEach((key) => {\n        expanded ? expandedKeysSet.add(key) : expandedKeysSet.delete(key);\n        onExpandEnd(key);\n      });\n      const newExpandedKeys = [...expandedKeysSet];\n      setExpandState(newExpandedKeys);\n      emitExpandEvent({\n        targetKey,\n        targetExpanded: isUndefined(targetKey) ? void 0 : expanded,\n        newExpandedKeys\n      });\n    }\n    function onCheck(checked, key, e) {\n      const node = key2TreeNode.value.get(key);\n      if (!node)\n        return;\n      const [newCheckedKeys, newIndeterminateKeys] = getCheckedStateByCheck({\n        node,\n        checked,\n        checkedKeys: checkedKeys.value,\n        indeterminateKeys: indeterminateKeys.value,\n        checkStrictly: checkStrictly.value\n      });\n      setCheckedState(newCheckedKeys, newIndeterminateKeys);\n      emitCheckEvent({\n        targetKey: key,\n        targetChecked: checked,\n        newCheckedKeys,\n        newIndeterminateKeys,\n        event: e\n      });\n    }\n    function onSelect(key, e) {\n      const node = key2TreeNode.value.get(key);\n      if (!node)\n        return;\n      let newSelectedKeys;\n      let selected;\n      if (multiple.value) {\n        const selectedKeysSet = new Set(selectedKeys.value);\n        selected = !selectedKeysSet.has(key);\n        selected ? selectedKeysSet.add(key) : selectedKeysSet.delete(key);\n        newSelectedKeys = [...selectedKeysSet];\n      } else {\n        selected = true;\n        newSelectedKeys = [key];\n      }\n      setSelectedState(newSelectedKeys);\n      emitSelectEvent({\n        targetKey: key,\n        targetSelected: selected,\n        newSelectedKeys,\n        event: e\n      });\n    }\n    function onExpand(expanded, key, e) {\n      if (currentExpandKeys.value.includes(key))\n        return;\n      const node = key2TreeNode.value.get(key);\n      if (!node)\n        return;\n      const expandedKeysSet = new Set(expandedKeys.value);\n      expanded ? expandedKeysSet.add(key) : expandedKeysSet.delete(key);\n      const newExpandedKeys = [...expandedKeysSet];\n      setExpandState(newExpandedKeys);\n      if (animation.value) {\n        currentExpandKeys.value.push(key);\n      }\n      emitExpandEvent({\n        targetKey: key,\n        targetExpanded: expanded,\n        newExpandedKeys,\n        event: e\n      });\n    }\n    function onExpandEnd(key) {\n      const index = currentExpandKeys.value.indexOf(key);\n      currentExpandKeys.value.splice(index, 1);\n    }\n    const onLoadMore = computed(() => (loadMore == null ? void 0 : loadMore.value) ? async (key) => {\n      if (!isFunction(loadMore.value))\n        return;\n      const node = key2TreeNode.value.get(key);\n      if (!node)\n        return;\n      const { treeNodeData } = node;\n      loadingKeys.value = [...new Set([...loadingKeys.value, key])];\n      try {\n        await loadMore.value(treeNodeData);\n        loadingKeys.value = loadingKeys.value.filter((v) => v !== key);\n        onExpand(true, key);\n        if (checkedKeys.value.includes(key)) {\n          onCheck(true, key);\n        }\n      } catch (err) {\n        loadingKeys.value = loadingKeys.value.filter((v) => v !== key);\n        console.error(\"[tree]load data error: \", err);\n      }\n    } : void 0);\n    const treeContext = reactive({\n      treeProps: props,\n      switcherIcon,\n      loadingIcon,\n      dragIcon,\n      nodeIcon,\n      nodeTitle,\n      nodeExtra,\n      treeData,\n      flattenTreeData,\n      key2TreeNode,\n      checkedKeys,\n      indeterminateKeys,\n      selectedKeys,\n      expandedKeys,\n      loadingKeys,\n      currentExpandKeys,\n      onLoadMore,\n      filterTreeNode,\n      onCheck,\n      onSelect,\n      onExpand,\n      onExpandEnd,\n      allowDrop(key, dropPosition) {\n        const node = key2TreeNode.value.get(key);\n        if (node && isFunction(allowDrop.value)) {\n          return !!allowDrop.value({\n            dropNode: node.treeNodeData,\n            dropPosition\n          });\n        }\n        return true;\n      },\n      onDragStart(key, e) {\n        const node = key2TreeNode.value.get(key);\n        dragNode.value = node;\n        if (node) {\n          emit(\"dragStart\", e, node.treeNodeData);\n        }\n      },\n      onDragEnd(key, e) {\n        const node = key2TreeNode.value.get(key);\n        dragNode.value = void 0;\n        if (node) {\n          emit(\"dragEnd\", e, node.treeNodeData);\n        }\n      },\n      onDragOver(key, e) {\n        const node = key2TreeNode.value.get(key);\n        if (node) {\n          emit(\"dragOver\", e, node.treeNodeData);\n        }\n      },\n      onDragLeave(key, e) {\n        const node = key2TreeNode.value.get(key);\n        if (node) {\n          emit(\"dragLeave\", e, node.treeNodeData);\n        }\n      },\n      onDrop(key, dropPosition, e) {\n        const node = key2TreeNode.value.get(key);\n        if (dragNode.value && node && !(node.key === dragNode.value.key || node.pathParentKeys.includes(dragNode.value.key || \"\"))) {\n          emit(\"drop\", {\n            e,\n            dragNode: dragNode.value.treeNodeData,\n            dropNode: node.treeNodeData,\n            dropPosition\n          });\n        }\n      }\n    });\n    provide(TreeInjectionKey, treeContext);\n    return {\n      classNames,\n      visibleTreeNodeList,\n      treeContext,\n      virtualListRef: ref(),\n      computedSelectedKeys: selectedKeys,\n      computedExpandedKeys: expandedKeys,\n      computedCheckedKeys: checkedKeys,\n      computedIndeterminateKeys: indeterminateKeys,\n      getPublicCheckedKeys,\n      getNodes,\n      internalCheckNodes: checkNodes,\n      internalSetCheckedKeys: setCheckedKeys,\n      internalSelectNodes: selectNodes,\n      internalSetSelectedKeys: setSelectedKeys,\n      internalExpandNodes: expandNodes,\n      internalSetExpandedKeys: setExpandedKeys\n    };\n  },\n  methods: {\n    toggleCheck(key, e) {\n      const { key2TreeNode, onCheck, checkedKeys } = this.treeContext;\n      const checked = !checkedKeys.includes(key);\n      const node = key2TreeNode.get(key);\n      if (node && isNodeCheckable(node)) {\n        onCheck(checked, key, e);\n      }\n    },\n    scrollIntoView(options) {\n      this.virtualListRef && this.virtualListRef.scrollTo(options);\n    },\n    getSelectedNodes() {\n      return this.getNodes(this.computedSelectedKeys);\n    },\n    getCheckedNodes(options = {}) {\n      const { checkedStrategy, includeHalfChecked } = options;\n      const checkedKeys = this.getPublicCheckedKeys(this.computedCheckedKeys, checkedStrategy);\n      const checkedNodes = this.getNodes(checkedKeys);\n      return [\n        ...checkedNodes,\n        ...includeHalfChecked ? this.getHalfCheckedNodes() : []\n      ];\n    },\n    getHalfCheckedNodes() {\n      return this.getNodes(this.computedIndeterminateKeys);\n    },\n    getExpandedNodes() {\n      return this.getNodes(this.computedExpandedKeys);\n    },\n    checkAll(checked = true) {\n      const { key2TreeNode } = this.treeContext;\n      const newKeys = checked ? [...key2TreeNode.keys()].filter((key) => {\n        const node = key2TreeNode.get(key);\n        return node && isNodeCheckable(node);\n      }) : [];\n      this.internalSetCheckedKeys(newKeys);\n    },\n    checkNode(key, checked = true, onlyCheckLeaf = false) {\n      const { checkStrictly, treeContext } = this;\n      const { key2TreeNode } = treeContext;\n      const isBatch = isArray(key);\n      const keys = (isBatch ? key : [key]).filter((key2) => {\n        const node = key2TreeNode.get(key2);\n        return node && isNodeCheckable(node) && (checkStrictly || !onlyCheckLeaf || isLeafNode(node));\n      });\n      this.internalCheckNodes(keys, checked, isBatch ? void 0 : key);\n    },\n    selectAll(selected = true) {\n      const { key2TreeNode } = this.treeContext;\n      const newKeys = selected ? [...key2TreeNode.keys()].filter((key) => {\n        const node = key2TreeNode.get(key);\n        return node && isNodeSelectable(node);\n      }) : [];\n      this.internalSetSelectedKeys(newKeys);\n    },\n    selectNode(key, selected = true) {\n      const { key2TreeNode } = this.treeContext;\n      const isBatch = isArray(key);\n      const keys = (isBatch ? key : [key]).filter((key2) => {\n        const node = key2TreeNode.get(key2);\n        return node && isNodeSelectable(node);\n      });\n      this.internalSelectNodes(keys, selected, isBatch ? void 0 : key);\n    },\n    expandAll(expanded = true) {\n      const { key2TreeNode } = this.treeContext;\n      const newKeys = expanded ? [...key2TreeNode.keys()].filter((key) => {\n        const node = key2TreeNode.get(key);\n        return node && isNodeExpandable(node);\n      }) : [];\n      this.internalSetExpandedKeys(newKeys);\n    },\n    expandNode(key, expanded = true) {\n      const { key2TreeNode } = this.treeContext;\n      const isBatch = isArray(key);\n      const keys = (isBatch ? key : [key]).filter((key2) => {\n        const node = key2TreeNode.get(key2);\n        return node && isNodeExpandable(node);\n      });\n      this.internalExpandNodes(keys, expanded, isBatch ? void 0 : key);\n    }\n  }\n});\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_TreeNode = resolveComponent(\"TreeNode\");\n  const _component_VirtualList = resolveComponent(\"VirtualList\");\n  return openBlock(), createElementBlock(\"div\", {\n    class: normalizeClass(_ctx.classNames)\n  }, [\n    _ctx.virtualListProps ? (openBlock(), createBlock(_component_VirtualList, mergeProps({\n      key: 0,\n      ref: \"virtualListRef\"\n    }, _ctx.virtualListProps, { data: _ctx.visibleTreeNodeList }), {\n      item: withCtx(({ item: node }) => [\n        createVNode(_component_TreeNode, mergeProps({\n          key: node.key\n        }, node.treeNodeProps), null, 16)\n      ]),\n      _: 1\n    }, 16, [\"data\"])) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(_ctx.visibleTreeNodeList, (node) => {\n      return openBlock(), createBlock(_component_TreeNode, mergeProps({\n        key: node.key\n      }, node.treeNodeProps), null, 16);\n    }), 128))\n  ], 2);\n}\nvar _Tree = /* @__PURE__ */ _export_sfc(_sfc_main, [[\"render\", _sfc_render]]);\nexport { _Tree as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}