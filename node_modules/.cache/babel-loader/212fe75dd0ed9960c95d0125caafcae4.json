{"ast":null,"code":"import { defineComponent, toRefs, computed, ref, reactive, onUnmounted, watch, nextTick } from \"vue\";\nimport { isUndefined, isString, isFunction } from \"../../_utils/is.js\";\nimport { caf, raf } from \"../../_utils/raf.js\";\nimport usePickSlots from \"../../_hooks/use-pick-slots.js\";\nimport ResizeObserver from \"../resize-observer.js\";\nimport RenderFunction from \"../render-function.js\";\nimport Filler from \"./filler.js\";\nimport { useViewportHeight } from \"./hooks/use-viewport-height.js\";\nimport { useItemHeight } from \"./hooks/use-item-height.js\";\nimport { useRenderChildren } from \"./hooks/use-render-children.js\";\nimport { useRangeState } from \"./hooks/use-range-state.js\";\nimport { useScrollTo } from \"./hooks/use-scroll-to.js\";\nimport { getItemAbsoluteTop, getValidScrollTop, getScrollPercentage } from \"./utils/index.js\";\n\nvar _sfc_main = defineComponent({\n  name: \"VirtualList\",\n  components: {\n    ResizeObserver,\n    Filler,\n    RenderFunction\n  },\n  inheritAttrs: false,\n  props: {\n    height: {\n      type: [Number, String],\n      default: 200\n    },\n    threshold: {\n      type: [Number, Object]\n    },\n    isStaticItemHeight: {\n      type: Boolean\n    },\n    estimatedItemHeight: {\n      type: Number\n    },\n    data: {\n      type: Array,\n      default: () => []\n    },\n    itemKey: {\n      type: [String, Function],\n      default: \"key\"\n    },\n    component: {\n      type: String,\n      default: \"div\"\n    },\n    type: String,\n    outerAttrs: Object,\n    innerAttrs: Object\n  },\n  emits: [\"scroll\", \"resize\"],\n\n  setup(props, {\n    slots,\n    emit\n  }) {\n    const {\n      height,\n      itemKey,\n      data,\n      estimatedItemHeight: propEstimatedItemHeight,\n      isStaticItemHeight,\n      threshold\n    } = toRefs(props);\n\n    function getItemKey(item, index) {\n      let result;\n\n      if (isString(itemKey.value)) {\n        result = item[itemKey.value];\n      } else if (isFunction(itemKey.value)) {\n        result = itemKey.value(item);\n      }\n\n      return result != null ? result : index;\n    }\n\n    const internalData = computed(() => (data.value || []).map((item, index) => ({\n      key: getItemKey(item, index),\n      index,\n      item\n    })));\n    const viewportRef = ref();\n    const {\n      viewportHeight,\n      setViewportHeight,\n      needMeasureViewportHeight\n    } = useViewportHeight(reactive({\n      height\n    }));\n    const {\n      itemHeight,\n      minItemHeight,\n      totalHeight,\n      setItemHeight,\n      getItemHeight,\n      getItemHeightOrDefault,\n      getItemHeightOrDefaultByIndex\n    } = useItemHeight(reactive({\n      estimatedItemHeight: propEstimatedItemHeight,\n      data: internalData\n    }));\n    const itemCount = computed(() => internalData.value.length);\n    const visibleCount = computed(() => Math.ceil(viewportHeight.value / minItemHeight.value));\n    const scrollTop = ref(0);\n    const startOffset = ref(0);\n    const {\n      rangeState,\n      updateRangeState\n    } = useRangeState(reactive({\n      viewportRef,\n      itemCount,\n      visibleCount\n    }));\n    const visibleData = computed(() => {\n      const start = rangeState.startIndex;\n      const end = Math.min(rangeState.endIndex + 1, itemCount.value);\n      return internalData.value.slice(start, end);\n    });\n    const isVirtual = computed(() => (threshold == null ? void 0 : threshold.value) !== null && ((threshold == null ? void 0 : threshold.value) === void 0 || itemCount.value >= threshold.value) && totalHeight.value > viewportHeight.value);\n    const scrollListPadding = computed(() => {\n      if (!isUndefined(viewportRef.value)) {\n        const viewport = viewportRef.value;\n\n        const getPadding = property => +window.getComputedStyle(viewport)[property].replace(/\\D/g, \"\");\n\n        return {\n          top: getPadding(\"paddingTop\"),\n          bottom: getPadding(\"paddingBottom\")\n        };\n      }\n\n      return {\n        top: 0,\n        bottom: 0\n      };\n    });\n    const itemRender = usePickSlots(slots, \"item\");\n    const renderChildren = useRenderChildren(reactive({\n      internalData,\n      visibleData,\n      itemRender\n    }), {\n      onItemResize(el, key) {\n        if (el && isUndefined(getItemHeight(key))) {\n          if (isStaticItemHeight.value) {\n            setItemHeight(key, itemHeight.value);\n          } else {\n            const height2 = el.offsetHeight;\n\n            if (height2) {\n              setItemHeight(key, height2);\n            }\n          }\n        }\n      }\n\n    });\n\n    const updateScrollOffset = () => {\n      if (!viewportRef.value || !isVirtual.value) return;\n      const {\n        scrollTop: scrollTop2,\n        clientHeight,\n        scrollHeight\n      } = viewportRef.value;\n      const scrollPtg = getScrollPercentage({\n        scrollTop: scrollTop2,\n        clientHeight,\n        scrollHeight\n      });\n      let newStartOffset = getItemAbsoluteTop({\n        scrollPtg,\n        clientHeight,\n        scrollTop: scrollTop2 - (scrollListPadding.value.top + scrollListPadding.value.bottom) * scrollPtg,\n        itemHeight: getItemHeightOrDefaultByIndex(rangeState.itemIndex),\n        itemOffsetPtg: rangeState.itemOffsetPtg\n      });\n\n      for (let index = rangeState.itemIndex - 1; index >= rangeState.startIndex; index--) {\n        newStartOffset -= getItemHeightOrDefaultByIndex(index);\n      }\n\n      startOffset.value = newStartOffset;\n    };\n\n    const rafIdRef = ref();\n    onUnmounted(() => {\n      rafIdRef.value && caf(rafIdRef.value);\n    });\n    const lockScrollRef = ref(false);\n    const {\n      fixScrollTo,\n      prepareScrollTo\n    } = useScrollTo(reactive({\n      isVirtual,\n      isStaticItemHeight,\n      rangeState,\n      data: internalData,\n      viewportRef,\n      scrollTop,\n      visibleCount,\n      getItemHeightOrDefault,\n      getItemHeightOrDefaultByIndex\n    }));\n\n    const handleResize = entry => {\n      handleWrapperResize(entry);\n      emit(\"resize\", entry);\n    };\n\n    const handleWrapperResize = entry => {\n      if (needMeasureViewportHeight.value) {\n        setViewportHeight(entry.clientHeight);\n      }\n    };\n\n    const handleScroll = e => {\n      if (!viewportRef.value) return;\n      const {\n        scrollTop: rawScrollTop,\n        clientHeight,\n        scrollHeight\n      } = viewportRef.value;\n      scrollTop.value = getValidScrollTop(rawScrollTop, scrollHeight - clientHeight);\n      emit(\"scroll\", e);\n    };\n\n    const scrollTo = options => {\n      rafIdRef.value && caf(rafIdRef.value);\n      rafIdRef.value = raf(() => {\n        const prepareScrollResult = prepareScrollTo(options);\n\n        if (prepareScrollResult) {\n          rangeState.startIndex = prepareScrollResult.startIndex;\n          rangeState.endIndex = prepareScrollResult.endIndex;\n          nextTick(() => {\n            if (!viewportRef.value) return;\n            const fixScrollResult = fixScrollTo({\n              itemIndex: prepareScrollResult.itemIndex,\n              relativeTop: prepareScrollResult.relativeTop\n            });\n\n            if (fixScrollResult) {\n              lockScrollRef.value = true;\n              viewportRef.value.scrollTop = fixScrollResult.scrollTop;\n              rangeState.itemIndex = fixScrollResult.itemIndex;\n              rangeState.itemOffsetPtg = fixScrollResult.itemOffsetPtg;\n              rangeState.startIndex = fixScrollResult.startIndex;\n              rangeState.endIndex = fixScrollResult.endIndex;\n            }\n\n            rafIdRef.value = raf(() => {\n              lockScrollRef.value = false;\n            });\n          });\n        }\n      });\n    };\n\n    watch([itemHeight, visibleCount, scrollTop, data], () => {\n      if (lockScrollRef.value) return;\n      updateRangeState();\n    });\n    watch(rangeState, () => {\n      updateScrollOffset();\n    });\n    return {\n      viewportRef,\n      viewportHeight,\n      totalHeight,\n      startOffset,\n      isVirtual,\n      renderChildren,\n      handleResize,\n      handleScroll,\n      scrollTo\n    };\n  }\n\n});\n\nexport { _sfc_main as default };","map":{"version":3,"names":["defineComponent","toRefs","computed","ref","reactive","onUnmounted","watch","nextTick","isUndefined","isString","isFunction","caf","raf","usePickSlots","ResizeObserver","RenderFunction","Filler","useViewportHeight","useItemHeight","useRenderChildren","useRangeState","useScrollTo","getItemAbsoluteTop","getValidScrollTop","getScrollPercentage","_sfc_main","name","components","inheritAttrs","props","height","type","Number","String","default","threshold","Object","isStaticItemHeight","Boolean","estimatedItemHeight","data","Array","itemKey","Function","component","outerAttrs","innerAttrs","emits","setup","slots","emit","propEstimatedItemHeight","getItemKey","item","index","result","value","internalData","map","key","viewportRef","viewportHeight","setViewportHeight","needMeasureViewportHeight","itemHeight","minItemHeight","totalHeight","setItemHeight","getItemHeight","getItemHeightOrDefault","getItemHeightOrDefaultByIndex","itemCount","length","visibleCount","Math","ceil","scrollTop","startOffset","rangeState","updateRangeState","visibleData","start","startIndex","end","min","endIndex","slice","isVirtual","scrollListPadding","viewport","getPadding","property","window","getComputedStyle","replace","top","bottom","itemRender","renderChildren","onItemResize","el","height2","offsetHeight","updateScrollOffset","scrollTop2","clientHeight","scrollHeight","scrollPtg","newStartOffset","itemIndex","itemOffsetPtg","rafIdRef","lockScrollRef","fixScrollTo","prepareScrollTo","handleResize","entry","handleWrapperResize","handleScroll","e","rawScrollTop","scrollTo","options","prepareScrollResult","fixScrollResult","relativeTop"],"sources":["/www/wwwroot/admin/node_modules/@arco-design/web-vue/es/_components/virtual-list/virtual-list.vue_vue&type=script&lang.js"],"sourcesContent":["import { defineComponent, toRefs, computed, ref, reactive, onUnmounted, watch, nextTick } from \"vue\";\nimport { isUndefined, isString, isFunction } from \"../../_utils/is.js\";\nimport { caf, raf } from \"../../_utils/raf.js\";\nimport usePickSlots from \"../../_hooks/use-pick-slots.js\";\nimport ResizeObserver from \"../resize-observer.js\";\nimport RenderFunction from \"../render-function.js\";\nimport Filler from \"./filler.js\";\nimport { useViewportHeight } from \"./hooks/use-viewport-height.js\";\nimport { useItemHeight } from \"./hooks/use-item-height.js\";\nimport { useRenderChildren } from \"./hooks/use-render-children.js\";\nimport { useRangeState } from \"./hooks/use-range-state.js\";\nimport { useScrollTo } from \"./hooks/use-scroll-to.js\";\nimport { getItemAbsoluteTop, getValidScrollTop, getScrollPercentage } from \"./utils/index.js\";\nvar _sfc_main = defineComponent({\n  name: \"VirtualList\",\n  components: {\n    ResizeObserver,\n    Filler,\n    RenderFunction\n  },\n  inheritAttrs: false,\n  props: {\n    height: {\n      type: [Number, String],\n      default: 200\n    },\n    threshold: {\n      type: [Number, Object]\n    },\n    isStaticItemHeight: {\n      type: Boolean\n    },\n    estimatedItemHeight: {\n      type: Number\n    },\n    data: {\n      type: Array,\n      default: () => []\n    },\n    itemKey: {\n      type: [String, Function],\n      default: \"key\"\n    },\n    component: {\n      type: String,\n      default: \"div\"\n    },\n    type: String,\n    outerAttrs: Object,\n    innerAttrs: Object\n  },\n  emits: [\"scroll\", \"resize\"],\n  setup(props, {\n    slots,\n    emit\n  }) {\n    const {\n      height,\n      itemKey,\n      data,\n      estimatedItemHeight: propEstimatedItemHeight,\n      isStaticItemHeight,\n      threshold\n    } = toRefs(props);\n    function getItemKey(item, index) {\n      let result;\n      if (isString(itemKey.value)) {\n        result = item[itemKey.value];\n      } else if (isFunction(itemKey.value)) {\n        result = itemKey.value(item);\n      }\n      return result != null ? result : index;\n    }\n    const internalData = computed(() => (data.value || []).map((item, index) => ({\n      key: getItemKey(item, index),\n      index,\n      item\n    })));\n    const viewportRef = ref();\n    const {\n      viewportHeight,\n      setViewportHeight,\n      needMeasureViewportHeight\n    } = useViewportHeight(reactive({\n      height\n    }));\n    const {\n      itemHeight,\n      minItemHeight,\n      totalHeight,\n      setItemHeight,\n      getItemHeight,\n      getItemHeightOrDefault,\n      getItemHeightOrDefaultByIndex\n    } = useItemHeight(reactive({\n      estimatedItemHeight: propEstimatedItemHeight,\n      data: internalData\n    }));\n    const itemCount = computed(() => internalData.value.length);\n    const visibleCount = computed(() => Math.ceil(viewportHeight.value / minItemHeight.value));\n    const scrollTop = ref(0);\n    const startOffset = ref(0);\n    const {\n      rangeState,\n      updateRangeState\n    } = useRangeState(reactive({\n      viewportRef,\n      itemCount,\n      visibleCount\n    }));\n    const visibleData = computed(() => {\n      const start = rangeState.startIndex;\n      const end = Math.min(rangeState.endIndex + 1, itemCount.value);\n      return internalData.value.slice(start, end);\n    });\n    const isVirtual = computed(() => (threshold == null ? void 0 : threshold.value) !== null && ((threshold == null ? void 0 : threshold.value) === void 0 || itemCount.value >= threshold.value) && totalHeight.value > viewportHeight.value);\n    const scrollListPadding = computed(() => {\n      if (!isUndefined(viewportRef.value)) {\n        const viewport = viewportRef.value;\n        const getPadding = (property) => +window.getComputedStyle(viewport)[property].replace(/\\D/g, \"\");\n        return {\n          top: getPadding(\"paddingTop\"),\n          bottom: getPadding(\"paddingBottom\")\n        };\n      }\n      return {\n        top: 0,\n        bottom: 0\n      };\n    });\n    const itemRender = usePickSlots(slots, \"item\");\n    const renderChildren = useRenderChildren(reactive({\n      internalData,\n      visibleData,\n      itemRender\n    }), {\n      onItemResize(el, key) {\n        if (el && isUndefined(getItemHeight(key))) {\n          if (isStaticItemHeight.value) {\n            setItemHeight(key, itemHeight.value);\n          } else {\n            const height2 = el.offsetHeight;\n            if (height2) {\n              setItemHeight(key, height2);\n            }\n          }\n        }\n      }\n    });\n    const updateScrollOffset = () => {\n      if (!viewportRef.value || !isVirtual.value)\n        return;\n      const {\n        scrollTop: scrollTop2,\n        clientHeight,\n        scrollHeight\n      } = viewportRef.value;\n      const scrollPtg = getScrollPercentage({\n        scrollTop: scrollTop2,\n        clientHeight,\n        scrollHeight\n      });\n      let newStartOffset = getItemAbsoluteTop({\n        scrollPtg,\n        clientHeight,\n        scrollTop: scrollTop2 - (scrollListPadding.value.top + scrollListPadding.value.bottom) * scrollPtg,\n        itemHeight: getItemHeightOrDefaultByIndex(rangeState.itemIndex),\n        itemOffsetPtg: rangeState.itemOffsetPtg\n      });\n      for (let index = rangeState.itemIndex - 1; index >= rangeState.startIndex; index--) {\n        newStartOffset -= getItemHeightOrDefaultByIndex(index);\n      }\n      startOffset.value = newStartOffset;\n    };\n    const rafIdRef = ref();\n    onUnmounted(() => {\n      rafIdRef.value && caf(rafIdRef.value);\n    });\n    const lockScrollRef = ref(false);\n    const {\n      fixScrollTo,\n      prepareScrollTo\n    } = useScrollTo(reactive({\n      isVirtual,\n      isStaticItemHeight,\n      rangeState,\n      data: internalData,\n      viewportRef,\n      scrollTop,\n      visibleCount,\n      getItemHeightOrDefault,\n      getItemHeightOrDefaultByIndex\n    }));\n    const handleResize = (entry) => {\n      handleWrapperResize(entry);\n      emit(\"resize\", entry);\n    };\n    const handleWrapperResize = (entry) => {\n      if (needMeasureViewportHeight.value) {\n        setViewportHeight(entry.clientHeight);\n      }\n    };\n    const handleScroll = (e) => {\n      if (!viewportRef.value)\n        return;\n      const {\n        scrollTop: rawScrollTop,\n        clientHeight,\n        scrollHeight\n      } = viewportRef.value;\n      scrollTop.value = getValidScrollTop(rawScrollTop, scrollHeight - clientHeight);\n      emit(\"scroll\", e);\n    };\n    const scrollTo = (options) => {\n      rafIdRef.value && caf(rafIdRef.value);\n      rafIdRef.value = raf(() => {\n        const prepareScrollResult = prepareScrollTo(options);\n        if (prepareScrollResult) {\n          rangeState.startIndex = prepareScrollResult.startIndex;\n          rangeState.endIndex = prepareScrollResult.endIndex;\n          nextTick(() => {\n            if (!viewportRef.value)\n              return;\n            const fixScrollResult = fixScrollTo({\n              itemIndex: prepareScrollResult.itemIndex,\n              relativeTop: prepareScrollResult.relativeTop\n            });\n            if (fixScrollResult) {\n              lockScrollRef.value = true;\n              viewportRef.value.scrollTop = fixScrollResult.scrollTop;\n              rangeState.itemIndex = fixScrollResult.itemIndex;\n              rangeState.itemOffsetPtg = fixScrollResult.itemOffsetPtg;\n              rangeState.startIndex = fixScrollResult.startIndex;\n              rangeState.endIndex = fixScrollResult.endIndex;\n            }\n            rafIdRef.value = raf(() => {\n              lockScrollRef.value = false;\n            });\n          });\n        }\n      });\n    };\n    watch([itemHeight, visibleCount, scrollTop, data], () => {\n      if (lockScrollRef.value)\n        return;\n      updateRangeState();\n    });\n    watch(rangeState, () => {\n      updateScrollOffset();\n    });\n    return {\n      viewportRef,\n      viewportHeight,\n      totalHeight,\n      startOffset,\n      isVirtual,\n      renderChildren,\n      handleResize,\n      handleScroll,\n      scrollTo\n    };\n  }\n});\nexport { _sfc_main as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}